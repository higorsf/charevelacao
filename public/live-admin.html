<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Transmitir Ao Vivo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&family=Dancing+Script:wght@700&display=swap" rel="stylesheet">
    <style>
        .font-dancing { font-family: 'Dancing Script', cursive; }
        .chat-message strong { font-family: 'Dancing Script', cursive; font-size: 1.25rem; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center h-screen p-4">
    <div id="password-modal" class="absolute inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-lg shadow-2xl">
            <h2 class="text-2xl font-bold mb-4">Acesso à Transmissão</h2>
            <p class="mb-4">Por favor, insira a senha da live para continuar.</p>
            <form id="password-form">
                <input type="password" id="live-password" class="w-full px-3 py-2 border rounded-lg mb-4" placeholder="Senha da live" required>
                <button type="submit" class="w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Entrar</button>
                <p id="password-error" class="text-red-500 text-sm text-center mt-2"></p>
            </form>
        </div>
    </div>

    <div id="main-content" class="hidden w-full h-full flex flex-col items-center justify-center">
        <h1 class="text-3xl font-bold mb-4">Página de Transmissão</h1>
        <div class="w-full max-w-4xl flex flex-col md:flex-row gap-4">
            <div class="flex-grow">
                <p class="mb-2 text-center">A sua câmara será partilhada com os convidados.</p>
                <div class="relative w-full bg-black rounded-lg shadow-lg">
                    <video id="localVideo" autoplay muted playsinline class="w-full rounded-lg"></video>
                    <div id="status" class="absolute top-2 left-2 bg-red-500 text-white text-sm font-bold px-2 py-1 rounded">● OFFLINE</div>
                </div>
                <div id="controls" class="mt-4 flex gap-4 hidden justify-center">
                    <button id="toggleVideoButton" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded">Pausar Vídeo e Áudio</button>
                    <button id="endButton" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">Encerrar Live</button>
                </div>
                <button id="startButton" class="mt-4 w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Iniciar Transmissão</button>
            </div>
            <div class="w-full md:w-80 bg-gray-200 p-4 rounded-lg shadow-lg flex flex-col border border-gray-300">
                <h2 class="text-xl font-bold mb-2 text-center text-gray-700 font-dancing">Chat Ao Vivo</h2>
                <div id="chat-box" class="flex-grow bg-white rounded p-2 overflow-y-auto h-64 md:h-auto"></div>
            </div>
        </div>
    </div>

    <script>
        const passwordModal = document.getElementById('password-modal');
        const passwordForm = document.getElementById('password-form');
        const passwordInput = document.getElementById('live-password');
        const passwordError = document.getElementById('password-error');
        const mainContent = document.getElementById('main-content');
        
        const startButton = document.getElementById('startButton');
        const controlsDiv = document.getElementById('controls');
        const toggleVideoButton = document.getElementById('toggleVideoButton');
        const endButton = document.getElementById('endButton');
        const localVideo = document.getElementById('localVideo');
        const statusDiv = document.getElementById('status');
        const chatBox = document.getElementById('chat-box');
        
        let localStream;
        const peerConnections = {}; // Um peer connection por espectador
        let ws; 
        const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

        // Lógica da Senha
        passwordForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            passwordError.textContent = '';
            try {
                const response = await fetch('/verify-live-password', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password: passwordInput.value })
                });
                if (response.ok) {
                    passwordModal.classList.add('hidden');
                    mainContent.classList.remove('hidden');
                    initializeWebSocket();
                } else {
                    const result = await response.json();
                    passwordError.textContent = result.message || 'Senha incorreta.';
                }
            } catch (err) {
                passwordError.textContent = 'Erro de conexão com o servidor.';
            }
        });

        function initializeWebSocket() {
            ws = new WebSocket(`ws://${window.location.host}`);

            ws.onopen = () => {
                ws.send(JSON.stringify({ type: 'broadcaster' }));
            };

            ws.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                
                switch(message.type) {
                    case 'chat':
                        addChatMessage(message.sender, message.text);
                        break;
                    
                    // **CORREÇÃO**: Lógica para lidar com novos espectadores.
                    case 'watcher': {
                        const watcherId = message.id; // Usar a propriedade 'id' correta
                        console.log(`Novo espectador [${watcherId}] quer se conectar.`);

                        const peerConnection = new RTCPeerConnection(configuration);
                        peerConnections[watcherId] = peerConnection;

                        // Adiciona as faixas de mídia se a stream já estiver ativa
                        if (localStream) {
                            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
                        }

                        peerConnection.onicecandidate = e => {
                            if (e.candidate) {
                                ws.send(JSON.stringify({ type: 'iceCandidate', candidate: e.candidate, toId: watcherId }));
                            }
                        };
                        
                        // Cria e envia a oferta de conexão para o novo espectador
                        try {
                            const offer = await peerConnection.createOffer();
                            await peerConnection.setLocalDescription(offer);
                            ws.send(JSON.stringify({ type: 'offer', sdp: offer, toId: watcherId }));
                            console.log(`Oferta enviada para o espectador [${watcherId}]`);
                        } catch (e) {
                            console.error("Erro ao criar oferta:", e);
                        }
                        break;
                    }

                    // **CORREÇÃO**: Lógica para receber a resposta do espectador.
                    case 'answer': {
                        const watcherId = message.fromId;
                        if (peerConnections[watcherId]) {
                            console.log(`Resposta recebida de [${watcherId}]`);
                            await peerConnections[watcherId].setRemoteDescription(new RTCSessionDescription(message.sdp));
                        }
                        break;
                    }

                    // **CORREÇÃO**: Lógica para receber os ICE candidates do espectador.
                    case 'iceCandidate': {
                        const watcherId = message.fromId;
                        if (peerConnections[watcherId] && message.candidate) {
                            await peerConnections[watcherId].addIceCandidate(new RTCIceCandidate(message.candidate));
                        }
                        break;
                    }

                    // **MELHORIA**: Lógica para limpar a conexão de um espectador que desconectou.
                    case 'watcher-disconnected': {
                        const watcherId = message.id;
                        if (peerConnections[watcherId]) {
                            console.log(`Espectador [${watcherId}] desconectou. Fechando conexão.`);
                            peerConnections[watcherId].close();
                            delete peerConnections[watcherId];
                        }
                        break;
                    }
                }
            };

            ws.onclose = () => console.log('WebSocket do transmissor fechado.');
            ws.onerror = (err) => console.error('Erro no WebSocket do transmissor:', err);
        }

        function addChatMessage(sender, text) {
            const msgEl = document.createElement('p');
            msgEl.className = 'chat-message mb-1';
            msgEl.innerHTML = `<strong class="text-gray-600">${sender}:</strong> ${text}`;
            chatBox.appendChild(msgEl);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        startButton.onclick = async () => {
            startButton.classList.add('hidden');
            statusDiv.textContent = '● A INICIAR...';
            statusDiv.classList.replace('bg-red-500', 'bg-yellow-500');
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;

                // **MELHORIA**: Se já houver espectadores esperando, adiciona as faixas de mídia
                // e renegocia a conexão com eles agora que o vídeo está disponível.
                Object.entries(peerConnections).forEach(async ([id, pc]) => {
                    console.log(`Adicionando stream para o espectador pré-existente [${id}]`);
                    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    ws.send(JSON.stringify({ type: 'offer', sdp: offer, toId: id }));
                });

                statusDiv.textContent = '● AO VIVO';
                statusDiv.classList.replace('bg-yellow-500', 'bg-green-500');
                controlsDiv.classList.remove('hidden');
            } catch(err) {
                console.error("Erro ao iniciar a live:", err);
                alert("Não foi possível aceder à câmara/microfone.");
                statusDiv.textContent = '● FALHA';
                startButton.classList.remove('hidden');
            }
        };

        toggleVideoButton.onclick = () => {
            if (!localStream) return;
            const videoEnabled = localStream.getVideoTracks()[0].enabled;
            localStream.getTracks().forEach(track => {
                track.enabled = !track.enabled;
            });
            toggleVideoButton.textContent = !videoEnabled ? 'Pausar Vídeo e Áudio' : 'Retomar Vídeo e Áudio';
        };

        endButton.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'end-live' }));
            }
            if (localStream) localStream.getTracks().forEach(track => track.stop());
            Object.values(peerConnections).forEach(pc => pc.close());
            statusDiv.textContent = '● ENCERRADA';
            statusDiv.classList.replace('bg-green-500', 'bg-red-500');
            controlsDiv.classList.add('hidden');
            startButton.classList.remove('hidden');
            startButton.textContent = 'Iniciar Nova Live';
        };
    </script>
</body>
</html>